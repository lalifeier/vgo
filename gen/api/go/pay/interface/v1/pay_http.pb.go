// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.5.3
// - protoc             (unknown)
// source: pay/interface/v1/pay.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationPayAsyncNotify = "/api.pay.service.v1.Pay/AsyncNotify"
const OperationPayGoPay = "/api.pay.service.v1.Pay/GoPay"
const OperationPayQueryBill = "/api.pay.service.v1.Pay/QueryBill"
const OperationPayQueryRefund = "/api.pay.service.v1.Pay/QueryRefund"
const OperationPayQuerySettle = "/api.pay.service.v1.Pay/QuerySettle"
const OperationPayQueryTrade = "/api.pay.service.v1.Pay/QueryTrade"
const OperationPayRefund = "/api.pay.service.v1.Pay/Refund"
const OperationPaySyncNotify = "/api.pay.service.v1.Pay/SyncNotify"

type PayHTTPServer interface {
	AsyncNotify(context.Context, *GoPayReq) (*GoPayReply, error)
	GoPay(context.Context, *GoPayReq) (*GoPayReply, error)
	QueryBill(context.Context, *GoPayReq) (*GoPayReply, error)
	QueryRefund(context.Context, *GoPayReq) (*GoPayReply, error)
	QuerySettle(context.Context, *GoPayReq) (*GoPayReply, error)
	QueryTrade(context.Context, *GoPayReq) (*GoPayReply, error)
	Refund(context.Context, *GoPayReq) (*GoPayReply, error)
	SyncNotify(context.Context, *GoPayReq) (*GoPayReply, error)
}

func RegisterPayHTTPServer(s *http.Server, srv PayHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/gopay", _Pay_GoPay0_HTTP_Handler(srv))
	r.POST("/v1/refund", _Pay_Refund0_HTTP_Handler(srv))
	r.POST("/v1/notify/{channel}/{transactionId}", _Pay_AsyncNotify0_HTTP_Handler(srv))
	r.POST("/v1/return/{channel}/{transactionId}", _Pay_SyncNotify0_HTTP_Handler(srv))
	r.POST("/v1/query/trade", _Pay_QueryTrade0_HTTP_Handler(srv))
	r.POST("/v1/query/refund", _Pay_QueryRefund0_HTTP_Handler(srv))
	r.POST("/v1/query/bill", _Pay_QueryBill0_HTTP_Handler(srv))
	r.POST("/v1/query/settle", _Pay_QuerySettle0_HTTP_Handler(srv))
}

func _Pay_GoPay0_HTTP_Handler(srv PayHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GoPayReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationPayGoPay)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GoPay(ctx, req.(*GoPayReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GoPayReply)
		return ctx.Result(200, reply)
	}
}

func _Pay_Refund0_HTTP_Handler(srv PayHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GoPayReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationPayRefund)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Refund(ctx, req.(*GoPayReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GoPayReply)
		return ctx.Result(200, reply)
	}
}

func _Pay_AsyncNotify0_HTTP_Handler(srv PayHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GoPayReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationPayAsyncNotify)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AsyncNotify(ctx, req.(*GoPayReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GoPayReply)
		return ctx.Result(200, reply)
	}
}

func _Pay_SyncNotify0_HTTP_Handler(srv PayHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GoPayReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationPaySyncNotify)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SyncNotify(ctx, req.(*GoPayReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GoPayReply)
		return ctx.Result(200, reply)
	}
}

func _Pay_QueryTrade0_HTTP_Handler(srv PayHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GoPayReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationPayQueryTrade)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.QueryTrade(ctx, req.(*GoPayReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GoPayReply)
		return ctx.Result(200, reply)
	}
}

func _Pay_QueryRefund0_HTTP_Handler(srv PayHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GoPayReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationPayQueryRefund)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.QueryRefund(ctx, req.(*GoPayReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GoPayReply)
		return ctx.Result(200, reply)
	}
}

func _Pay_QueryBill0_HTTP_Handler(srv PayHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GoPayReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationPayQueryBill)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.QueryBill(ctx, req.(*GoPayReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GoPayReply)
		return ctx.Result(200, reply)
	}
}

func _Pay_QuerySettle0_HTTP_Handler(srv PayHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GoPayReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationPayQuerySettle)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.QuerySettle(ctx, req.(*GoPayReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GoPayReply)
		return ctx.Result(200, reply)
	}
}

type PayHTTPClient interface {
	AsyncNotify(ctx context.Context, req *GoPayReq, opts ...http.CallOption) (rsp *GoPayReply, err error)
	GoPay(ctx context.Context, req *GoPayReq, opts ...http.CallOption) (rsp *GoPayReply, err error)
	QueryBill(ctx context.Context, req *GoPayReq, opts ...http.CallOption) (rsp *GoPayReply, err error)
	QueryRefund(ctx context.Context, req *GoPayReq, opts ...http.CallOption) (rsp *GoPayReply, err error)
	QuerySettle(ctx context.Context, req *GoPayReq, opts ...http.CallOption) (rsp *GoPayReply, err error)
	QueryTrade(ctx context.Context, req *GoPayReq, opts ...http.CallOption) (rsp *GoPayReply, err error)
	Refund(ctx context.Context, req *GoPayReq, opts ...http.CallOption) (rsp *GoPayReply, err error)
	SyncNotify(ctx context.Context, req *GoPayReq, opts ...http.CallOption) (rsp *GoPayReply, err error)
}

type PayHTTPClientImpl struct {
	cc *http.Client
}

func NewPayHTTPClient(client *http.Client) PayHTTPClient {
	return &PayHTTPClientImpl{client}
}

func (c *PayHTTPClientImpl) AsyncNotify(ctx context.Context, in *GoPayReq, opts ...http.CallOption) (*GoPayReply, error) {
	var out GoPayReply
	pattern := "/v1/notify/{channel}/{transactionId}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationPayAsyncNotify))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *PayHTTPClientImpl) GoPay(ctx context.Context, in *GoPayReq, opts ...http.CallOption) (*GoPayReply, error) {
	var out GoPayReply
	pattern := "/v1/gopay"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationPayGoPay))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *PayHTTPClientImpl) QueryBill(ctx context.Context, in *GoPayReq, opts ...http.CallOption) (*GoPayReply, error) {
	var out GoPayReply
	pattern := "/v1/query/bill"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationPayQueryBill))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *PayHTTPClientImpl) QueryRefund(ctx context.Context, in *GoPayReq, opts ...http.CallOption) (*GoPayReply, error) {
	var out GoPayReply
	pattern := "/v1/query/refund"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationPayQueryRefund))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *PayHTTPClientImpl) QuerySettle(ctx context.Context, in *GoPayReq, opts ...http.CallOption) (*GoPayReply, error) {
	var out GoPayReply
	pattern := "/v1/query/settle"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationPayQuerySettle))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *PayHTTPClientImpl) QueryTrade(ctx context.Context, in *GoPayReq, opts ...http.CallOption) (*GoPayReply, error) {
	var out GoPayReply
	pattern := "/v1/query/trade"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationPayQueryTrade))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *PayHTTPClientImpl) Refund(ctx context.Context, in *GoPayReq, opts ...http.CallOption) (*GoPayReply, error) {
	var out GoPayReply
	pattern := "/v1/refund"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationPayRefund))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *PayHTTPClientImpl) SyncNotify(ctx context.Context, in *GoPayReq, opts ...http.CallOption) (*GoPayReply, error) {
	var out GoPayReply
	pattern := "/v1/return/{channel}/{transactionId}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationPaySyncNotify))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
