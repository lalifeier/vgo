// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.4

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type ShopHTTPServer interface {
	CreateDict(context.Context, *CreateDictReq) (*CreateDictResp, error)
	DeleteDict(context.Context, *DeleteDictReq) (*DeleteDictResp, error)
	GetDict(context.Context, *GetDictReq) (*GetDictResp, error)
	ListDict(context.Context, *ListDictReq) (*ListDictResp, error)
	PageListDict(context.Context, *PageListDictReq) (*PageListDictResp, error)
	UpdateDict(context.Context, *UpdateDictReq) (*UpdateDictResp, error)
}

func RegisterShopHTTPServer(s *http.Server, srv ShopHTTPServer) {
	r := s.Route("/")
	r.POST("/api/dict", _Shop_CreateDict0_HTTP_Handler(srv))
	r.PUT("/api/dict/{id}", _Shop_UpdateDict0_HTTP_Handler(srv))
	r.DELETE("/api/dict/{id}", _Shop_DeleteDict0_HTTP_Handler(srv))
	r.GET("/api/dicts", _Shop_ListDict0_HTTP_Handler(srv))
	r.GET("/api/dict", _Shop_PageListDict0_HTTP_Handler(srv))
	r.GET("/api/dict/{id}", _Shop_GetDict0_HTTP_Handler(srv))
}

func _Shop_CreateDict0_HTTP_Handler(srv ShopHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateDictReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.shop.admin.v1.Shop/CreateDict")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateDict(ctx, req.(*CreateDictReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateDictResp)
		return ctx.Result(200, reply)
	}
}

func _Shop_UpdateDict0_HTTP_Handler(srv ShopHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateDictReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.shop.admin.v1.Shop/UpdateDict")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateDict(ctx, req.(*UpdateDictReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateDictResp)
		return ctx.Result(200, reply)
	}
}

func _Shop_DeleteDict0_HTTP_Handler(srv ShopHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteDictReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.shop.admin.v1.Shop/DeleteDict")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteDict(ctx, req.(*DeleteDictReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteDictResp)
		return ctx.Result(200, reply)
	}
}

func _Shop_ListDict0_HTTP_Handler(srv ShopHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListDictReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.shop.admin.v1.Shop/ListDict")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListDict(ctx, req.(*ListDictReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListDictResp)
		return ctx.Result(200, reply)
	}
}

func _Shop_PageListDict0_HTTP_Handler(srv ShopHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in PageListDictReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.shop.admin.v1.Shop/PageListDict")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.PageListDict(ctx, req.(*PageListDictReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*PageListDictResp)
		return ctx.Result(200, reply)
	}
}

func _Shop_GetDict0_HTTP_Handler(srv ShopHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetDictReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.shop.admin.v1.Shop/GetDict")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetDict(ctx, req.(*GetDictReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetDictResp)
		return ctx.Result(200, reply)
	}
}

type ShopHTTPClient interface {
	CreateDict(ctx context.Context, req *CreateDictReq, opts ...http.CallOption) (rsp *CreateDictResp, err error)
	DeleteDict(ctx context.Context, req *DeleteDictReq, opts ...http.CallOption) (rsp *DeleteDictResp, err error)
	GetDict(ctx context.Context, req *GetDictReq, opts ...http.CallOption) (rsp *GetDictResp, err error)
	ListDict(ctx context.Context, req *ListDictReq, opts ...http.CallOption) (rsp *ListDictResp, err error)
	PageListDict(ctx context.Context, req *PageListDictReq, opts ...http.CallOption) (rsp *PageListDictResp, err error)
	UpdateDict(ctx context.Context, req *UpdateDictReq, opts ...http.CallOption) (rsp *UpdateDictResp, err error)
}

type ShopHTTPClientImpl struct {
	cc *http.Client
}

func NewShopHTTPClient(client *http.Client) ShopHTTPClient {
	return &ShopHTTPClientImpl{client}
}

func (c *ShopHTTPClientImpl) CreateDict(ctx context.Context, in *CreateDictReq, opts ...http.CallOption) (*CreateDictResp, error) {
	var out CreateDictResp
	pattern := "/api/dict"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.shop.admin.v1.Shop/CreateDict"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ShopHTTPClientImpl) DeleteDict(ctx context.Context, in *DeleteDictReq, opts ...http.CallOption) (*DeleteDictResp, error) {
	var out DeleteDictResp
	pattern := "/api/dict/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.shop.admin.v1.Shop/DeleteDict"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ShopHTTPClientImpl) GetDict(ctx context.Context, in *GetDictReq, opts ...http.CallOption) (*GetDictResp, error) {
	var out GetDictResp
	pattern := "/api/dict/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.shop.admin.v1.Shop/GetDict"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ShopHTTPClientImpl) ListDict(ctx context.Context, in *ListDictReq, opts ...http.CallOption) (*ListDictResp, error) {
	var out ListDictResp
	pattern := "/api/dicts"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.shop.admin.v1.Shop/ListDict"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ShopHTTPClientImpl) PageListDict(ctx context.Context, in *PageListDictReq, opts ...http.CallOption) (*PageListDictResp, error) {
	var out PageListDictResp
	pattern := "/api/dict"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.shop.admin.v1.Shop/PageListDict"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ShopHTTPClientImpl) UpdateDict(ctx context.Context, in *UpdateDictReq, opts ...http.CallOption) (*UpdateDictResp, error) {
	var out UpdateDictResp
	pattern := "/api/dict/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.shop.admin.v1.Shop/UpdateDict"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
